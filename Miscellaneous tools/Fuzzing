6.2.3 Fuzzing Approaches
Fuzzing is extensively used in vulnerability testing [137] to introduce malformed data or mutate nominal values to trigger flawed code in applications. Fuzzing techniques are usually very cheap to deploy, do not suffer from false positives, but lack an expected-result model and therefore rely on crashes and fails to assign a verdict. Two main fuzzing techniques exist: mutation based and generation based. Mutation fuzzing consists of altering a sample file or data following specific heuristics, while generation-based fuzzers take the input specification and generate test cases from it. Fuzzing may be used for crafting malicious input data [138], or crafting erroneous communication messages [139].

The approach presented by Duchene [138] consists of modeling the attacker's behavior, and driving this model by a genetic algorithm that evolves SUT input sequences. It requires a state-aware model of the SUT, either derived from an ASLan++ description or inferred from traces of valid/expected SUT execution. This model is then annotated using input taint data-flow analysis, to spot possible reflections. Concrete SUT inputs are generated with respect to an Attack Input Grammar which produces fuzzed values for reflected SUT input parameters. The fitness function depends on the obtained SUT output following the injection of a concrete SUT input. It computes the veracity of an input by looking for correlations, using the string distance between a given input parameter value and a substring of the output. Two genetic operators are used: mutation and cross-over. It is an efficient technique for detecting XSS, as it goes beyond the classical XSS evasion filters that may not be exhaustive. Such a technique also tackles multistep XSS discovery by using a more complex string matching algorithm to generate an annotated FSM, in order to inspect the SUT to find the possibilities of XSS at certain places.

A model-based behavioral fuzzing approach has been designed by Wang et al. [139] to discover vulnerabilities of Database Management Systems (DBMS). A DBMS defines a format rule that specifies packet format and a behavior rule that specifies its semantics and functionality. This approach is based on two main artifacts. The first artifact is a behavioral model, which includes fuzzing patterns and behavioral sequences. This is obtained from a behavior analysis of DBMS (protocol format analysis, attack surface analysis, etc.). A fuzzing pattern expresses the data structure of packets, the needs of security testing, and the design strategy for vulnerability discovery. A behavioral sequence defines the message transfer order between client and DBMS. The second artifact is a DBMS Fuzzer composed of a test instance (a detailed test script based on fuzzing patterns), and a finite state machine model EXT-NSFSM used for semivalid test case generation based on behavioral sequences and test instances. The authors describe a general framework for behavioral fuzzing that has been implemented and used in several experiments. It allows for the generation of thousands of fuzzing instances, and despite a few errors of analysis and script, the tool was able to discover buffer overflow vulnerabilities, 10 of which were not released yet.
