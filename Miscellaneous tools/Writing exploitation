Finding exploitable stack overflows in closed-source software
Finding new exploitable vulnerabilities, of any nature, in closed-source software is largely a black art. By comparison to other security topics, it is poorly documented. Furthermore, it relies on a combination of interdependent techniques. Useful tools include disassemblers, debuggers, tracers, and fuzzers. Disassemblers and debuggers are a lot more powerful tools than tracers and fuzzers. Disassemblers revert code back to assembly, while debuggers allow you to interactively control the application you are testing in a step-by-step nature (examining memory, writing to memory, and other similar functions). IDA is the best disassembler and recently added debugger support, although both SoftlCE (Win32 only) and gdb offer far more extensive debugging capabilities. (Win32 refers to 32-bit Microsoft Windows operating systems such as Microsoft Windows NT 4.0, Windows 2000, and Windows XP Professional.) Tracers are simply in-line and largely automated debuggers that step through an application with minimal interactivity from the user. Fuzzers are an often-used but incomplete method of testing that is akin to low-quality bruteforcing.

Note

Fuzzers try to use an automated approach to finding new bugs in software. They tend to work by sending what they assume to be unexpected input for the target application. For example, a fuzzer may attempt to log in to an FTP server 500,000 times using various usernames and passwords of random lengths, such as short lengths or abnormally long lengths. The fuzzer would potentially use every (or many) possible combinations until the FTP server elicited an abnormal response. Furthermore, the bug researcher could be monitoring the FTP server with a tracer to check for a difference in how the FTP server handled the input from the backend. This type of random guesswork approach does tend to work in the wild for largely unaudited programs.

Fuzzers do more than simply send 8000 letter “A”s to the authentication piece of a network protocol, but unfortunately, not a lot more. They are ideal for quickly checking for common, easy-to-find mistakes (after writing an extensive and custom fuzzer for the application in question), but not much more than that. The most promising in-development public fuzzer is SPIKE.
